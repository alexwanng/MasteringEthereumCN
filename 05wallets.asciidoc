[[wallets_chapter]]
== 钱包

((("wallets", id="ix_05wallets-asciidoc0", range="startofrange")))在以太坊中，钱包描述了一些不同的东西。

钱包在以太坊中处于一个较高的层次——应用层，是以太坊的主要用户界面。钱包控制着用户对钱的访问、管理秘钥和钱包地址、跟踪余额以及创建和签署交易。另外，一些以太坊钱包能够通过合约进行互动（interact ），比如ERC20代币（通过以太坊来发行的一种币）。

((("wallets","defined")))简单来讲，从一个程序员的角度看，钱包就是指用来存储和管理用户秘钥的一个系统。每一个钱包都有一个秘钥管理组件。甚至对于某些钱包来说，这就是它所有的功能。其他的钱包则分成了更广泛的类别，比如说_浏览器_——基于以太坊的去中心化的应用，或者 _DApps_, 我们将会在 <<去中心化的应用>>. 这一章详细介绍。它们都属于钱包，但没有明确的分界线来区分不同的类别。

在本章中，我们将钱包看做存储私钥的容器以及管理秘钥的系统。

[[wallet_tech_overview]]
=== 钱包技术简要

((("wallets","technology overview", id="ix_05wallets-asciidoc1", range="startofrange")))在这一节，我们总结了用于构建用户友好型、安全且灵活的钱包的一些技术。

设计钱包的一个关键因素是平衡方便性和隐私性。最方便的以太坊钱包是一个带有单个私钥和地址的钱包，可以重复使用。不幸的是，这样的设计对于隐私性来说是一个噩梦，因为任何人都能够很容易的跟踪并收集你的所有交易信息。另外一种方法，每一笔交易都使用一个新的秘钥，这是最能保护隐私性的办法，但是管理起来很麻烦。隐私性和方便性是很难平衡的，所以好的钱包设计是非常重要的。

人们对以太坊有一个常见的误解——以太坊钱包包含了以太币和其他代币。事实上，严格来说，一个钱包只是用来存储秘钥的。钱包里的以太币和其他代币记录在区块链上。用户可以通过钱包中的秘钥对交易进行签名，来控制网络中的代币。从某种意义上讲，以太坊钱包就是_钥匙扣_（keychain）。话虽如此，由于与别人进行代币交易唯一需要的就是钱包中的秘钥，所以我们也可以认为以太坊钱包包含了以太币和其他代币。重要的区别在于交易者的心态在不同的交易系统（从中心化的系统交易到去中心化的系统）交易引起的改变，在中心化的银行进行交易，只有交易者和银行能够看到交易者账户的余额，如果交易者想要进行一笔交易，他仅需要说服银行就行；而如果在区块链系统的去中心化平台进行交易，每个人都能看到这个账户的余额，尽管他们并不知道账户的拥有者是谁，并且每个人都需要确信所有者希望转移资金进行交易。实际上，这也意味着我们不需要钱包就能查询账户的余额。另外，如果你不喜欢你正在使用的这个钱包软件，你也可以将代币转移到其他的钱包。

[注意]
====
以太坊钱包仅包含秘钥，不包含以太币和其他代币。钱包就像一个钥匙扣一样存储公钥和私钥。用户通过私钥来签署交易，从而证明用户拥有这些以太币。以太币存储在区块链中。
====

现在主要有两种类型的钱包，区别在于它们包含的密钥是否相互关联。

((("nondeterministic (random) wallets", id="ix_05wallets-asciidoc2", range="startofrange")))((("random (nondeterministic) wallets", id="ix_05wallets-asciidoc3", range="startofrange")))((("wallets","nondeterministic", id="ix_05wallets-asciidoc4", range="startofrange")))第一种是_不确定性_（nondeterministic ）钱包，其中每个秘钥都是由不同的随机数独立生成的。秘钥之间没有关联。((("JBOK wallets", seealso="nondeterministic (random) wallets")))这种类型的钱包也被称为JBOK钱包，来自短语“Just a Bunch of Keys”（只是一串钥匙）。

((("deterministic (seeded) wallets","defined")))((("wallets","deterministic")))第二种是_确定性_（deterministic）钱包，其中所有的秘钥都来自一个主密钥，称之为_种子_。所有的秘钥之间都是互相关联的，并且如果一个人有主密钥的话，还可以再次生成。((("key derivation methods")))确定性钱包中使用了许多不同的密钥派生方法。最常用的派生方法使用树状结构，如<<hd_wallets>>中所述。

((("mnemonic code words")))((("seeds","mnemonic code words for")))为了使确定性钱包更安全，防止数据丢失事故，例如手机被盗或丢弃在厕所中，种子通常被编码为单词列表（英语或其他语言）。我们称这个单词列表为_助记词_。助记词更易于记录并且在发生事故时，我们可以通过助记词来找回钱包。当然，如果有人掌握了你的助记词，那么他们也可以重新创建你的钱包，从而获得你的以太币和智能合约的访问权限。因此，对你的助记词一定要非常非常小心！切勿将其存储在文件、电脑或手机上。将其写在纸上并存放在安全可靠的地方。

接下来的几节将介绍这些高级别的技术。


[[random_wallet]]
==== 不确定性(随机性)钱包

在第一个以太坊钱包中（为以太坊预售生产的），每一个钱包文件存储一个随机生成的私钥。这样的钱包正在被确定性钱包所替代，因为这些“老式”钱包在很多地方是处于劣势的。例如，在使用以太坊时，避免钱包地址的重复使用来达到最大化隐私安全性——每次接受一笔代币都使用一个新的地址（同时会产生一个新的私钥），这被认为是良好的做法。你还可以更进一步，每进行一笔交易就是用一个新的地址，尽管在交易大量代币时，会产生比较昂贵的费用。按照这种做法，一个不确定性钱包里的秘钥会不断增加，这就意味着你需要定期的备份这些秘钥。但是如果在备份之前丢失了这些数据（如磁盘故障、饮酒事故、手机被盗），你就会失去你对资金和智能合约的控制权限。“类型0”不确定性钱包是最难处理的，因为它们用一个“即时”的方式为每个钱包地址创建新的钱包文件。

((("keystore file")))尽管如此，许多以太坊客户端(包括geth)使用_密钥库_文件，这是一个json编码的文件，其中包含一个(随机生成的)私钥，为了增加安全性，它使用密码进行加密。 秘钥库文件的内容如下:

[[keystore_example]]
[source,json]
----
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
----

((("key derivation function (KDF)")))((("password stretching algorithm")))密钥库使用密钥求导函数(KDF)，也称为密码拉伸算法，这种算法可以抵御暴力破解、字典式攻击和彩虹表攻击。 简单来说，私钥不直接使用密码加密。相反，通过反复执行哈希函数，密码长度变长（stretched）了。哈希函数被重复了262144次，这可以在秘钥库的JSON文件中看到——参数crypto.kdfparams.n的值。 如果攻击者想要暴力破解密码，那么他每尝试一个密码都需要进行262144次的哈希处理，这样就足以减慢攻击速度，使他们无法暴力破解足够复杂并且长度很长的密码。

有许多软件库可以读写秘钥库的格式，例如JavaScript库 https://github.com/ethereumjs/keythereum[+keythereum+].

[TIP]
====
除了简单的测试外，我们不鼓励使用不确定性钱包。除了在最基本的情况下，不确定性钱包在各方面都由于它太笨重了而难以备份和使用。相反，使用行业标准的用助记词种子来备份的分层确定性钱包。(((range="endofrange", startref="ix_05wallets-asciidoc4")))(((range="endofrange", startref="ix_05wallets-asciidoc3")))(((range="endofrange", startref="ix_05wallets-asciidoc2")))
====

[[deterministic_wallets]]
==== 确定性(种子)钱包

((("deterministic (seeded) wallets","about")))((("wallets","deterministic")))确定性钱包或"种子"钱包包的私钥全部来自一个主密钥或种子。种子 是一个随机生成的数字，它与其他数据(如索引号或"链码"(请参阅 <<extended_keys>>)结合在一起，从而生成任意数量的私钥。在确定性钱包中，种子足以恢复所有派生的密钥，因此在创建时备份一次，就足以保证钱包中所有资金和智能合同的安全。 该种子还可以用于钱包的导出或导入，使所有秘钥在不同的钱包之间方便地迁移。

这种设计使得种子的安全性至关重要，因为只需要种子就可以访问整个钱包。 另一方面，能够将安全工作集中在单个数据上可以被视为一种优势。

[[hd_wallets]]
==== 分层确定性钱包(BIP-32 / BIP-44)

((("Bitcoin improvement proposals (BIPs)","Hierarchical Deterministic Wallets (BIP-32/BIP-44)")))((("hierarchical deterministic wallets (BIP-32/BIP-44)"))) 确定性钱包的发展，使它很容易从一个种子得到许多密钥。 目前，最先进的确定性钱包形式是由比特币的 http://bit.ly/2B2vQWs[_BIP-32 standard_] 定义的_分层次确定性_(HD)钱包. 分层次确定性钱包包含了由树状结构派生出来的密钥，父密钥可以派生出一系列子密钥，每个子密钥可以派生出一系列孙子密钥，等等。 这种树状结构在 <<hd_wallets_figure>>中进行了说明。

[[hd_wallets_figure]]
.HD 钱包: 一颗种子生成的钥匙树
image::images/hd_wallet.png["HD wallet"]

HD 钱包相较于简单的确定性钱包有几个关键的优势. 首先, 树状结构可以看做是一个组织结构, 一个特定的子秘钥所在的分支可以用来收款，再选用另一个分支用来记录付款. 密钥的分支也可以用来规划公司，将不同的分支用来分配给部门、子公司、特定功能或者会计部门。

HD钱包的第二个优点是，用户可以创建一系列公钥，而无需访问相应的私钥。 这使得HD钱包可以在不安全的服务器上使用，或者在只能接收或只能查看的情况下使用，在这种情况下钱包可以没有用于花费资金的私钥。

[[mnemonic_codes]]
==== 种子和助记词(BIP-39)

((("BIP-39 standard")))((("Bitcoin improvement proposals (BIPs)","Mnemonic Code Words (BIP-39)")))((("mnemonic code words","BIP-39")))((("seeds","mnemonic code words for", seealso="mnemonic code words")))((("wallets","mnemonic codes (BIP-39)")))为了安全备份和恢复钱包，有许多方法可以对私钥进行编码。当前首选的方法是使用一系列单词, 当这些单词以正确的顺序组合在一起时既可以重建私钥. 这些单词被称为_助记词_, 这个方法也被标准化为 http://bit.ly/2OEMjUz[BIP-39]. 今天，许多以太坊钱包(以及其他加密货币钱包)都使用这一标准，并且可以通过操作助记词来导入或导出用于备份和恢复的种子。

为了解释为什么这种方法会流行起来，让我们来看一个例子:

[[hex_seed_example]]
.用十六进制来表示一个确定性钱包的种子
----
FCCF1AB3329FD5DA3DA9577511F8F137
----

[[mnemonic_seed_example]]
.用12个助记词来表示一个确定性钱包的种子
----
wolf juice proud gown wool unfair
wall cliff insect more detail hub
----

实际上，在记录这个16进制的序列时出错的概率很大. 相反, 用已知的单词来记录就很简单, 主要在于单词（特别是英文单词）在记录过程中存在高度的冗余(redundancy).如果不小心将一个单词记录为 "inzect" , 在恢复钱包时就很容易发现这个错误，因为"inzect"不是一个正确的英文单词，也很容易能够看出正确单词为"insect"。我们在讨论种子的备份，因为这个管理HD钱包的良好行为： 种子需要在数据丢失(无论是通过事故还是盗窃)的情况下恢复钱包，所以保持备份是非常谨慎的。然而，种子必须保持非常隐私的状态，所以应该避免使用电子备份; 因此，早期的建议是用笔和纸进行备份。

总之，对于一个HD钱包来说，使用对种子编码得到的用于恢复钱包的助记词，能够安全地导出、抄写、在纸上记录、浏览并且导入私钥到另一个钱包中。(((range="endofrange", startref="ix_05wallets-asciidoc1")))


[[wallet_best_practices]]
=== 钱包最佳实践

((("wallets","best practices for", id="ix_05wallets-asciidoc5", range="startofrange")))随着加密货币钱包技术的成熟，某些通用的行业标准已经出现，使钱包具有广泛的互动性、易用性、安全性和灵活性。 这些标准还允许钱包从一个助记词中获得多种不同加密货币的密钥。 这些共同标准是:

* 基于 BIP-39的助记词
* HD 钱包，基于 BIP-32
* 基于 BIP-43的多用途 HD 钱包
* 基于 BIP-44的多币种和多帐户钱包

这些标准可能会随着未来的发展而改变或者被淘汰，但是现在它们形成了一套连锁技术，成为大多数区块链平台及其加密货币事实上的钱包标准。

这些标准已经被广泛的软件和硬件钱包所采用，使得所有这些钱包具有互动性。 用户可以导出这些钱包中产生的助记词，并将其导入另一个钱包，恢复所有秘钥和地址。

支持这些标准的一些软件钱包示例包括(按字母顺序列出) Jaxx、 MetaMask、 MyCrypto 和 MyEtherWallet (MEW)。 支持这些标准的硬件钱包包括 Keepkey、 Ledger 和 Trezor。

下面的部分将详细研究这些技术。

[TIP]
====
如果你正在实现一个以太坊钱包，那么应该将其作为一个 HD 钱包进行构建，备份时将种子编码为助记词，并遵循接下来所讲的这些标准： BIP-32、 BIP-39、 BIP-43和 BIP-44。
====

[[bip39]]
[[mnemonic_code_words]]
==== 助记词(BIP-39)

((("BIP-39 standard", id="ix_05wallets-asciidoc6", range="startofrange")))((("Bitcoin improvement proposals (BIPs)","Mnemonic Code Words (BIP-39)", id="ix_05wallets-asciidoc7", range="startofrange")))((("mnemonic code words","BIP-39", id="ix_05wallets-asciidoc8", range="startofrange")))((("wallets","mnemonic codes (BIP-39)", id="ix_05wallets-asciidoc9", range="startofrange")))助记词是对随机数进行编码生成的单词序列，这些单词序列就是钱包的种子。助记词能够重新创建种子，有这个种子可以重新创建钱包和秘钥。在第一次创建确定性钱包时，用户可以得到12到24个单词。这些单词就是助记词。正如我们前边所说的，助记词使用户更方便的备份钱包，因为它们易于阅读和正确地抄写。

[NOTE]
====
((("brainwallets, mnemonic words vs."))) 助记词常常与"脑钱包"相混淆，它们是不一样的。 最主要的区别在于，脑钱包由用户选择的单词组成，而助记词是由钱包随机创建并呈现给用户的。 这个重要的区别使得助记词更加安全，因为人类的选择性往往能够降低随机性。更重要的是，使用"脑钱包"意味着必须记住这些单词，这是一个糟糕的想法，因为有可能在需要的时候发现没有备份。
====

助记码是在 BIP-39中定义的。 请注意，BIP-39是助记词的标准的实现之一。 还有有一个不同的标准，用一组不同的单词，用于 eleclum 比特币钱包并且早于 BIP-39。 Bip-39是由 Trezor 硬件钱包背后的公司提出的并且 Electrum 不兼容。 然而，BIP-39由于其互动性的实现，现在已经获得了广泛的行业支持，事实上，它已经成为了行业标准。 此外，BIP-39可以用来生产支持以太坊的多币种的钱包，而Electrum 不能。

Bip-39定义了助记词和种子的创建，我们在这里用九个步骤来描述。 为了清晰起见，这个过程被分成两部分: 第一步到第六步显示了 <<generating_mnemonic_words>> ，第七步到第九步显示了 <<mnemonic_to_seed>>.

[[generating_mnemonic_words]]
===== 生成助记词

((("BIP-39 standard","generating code words with")))((("checksum","in mnemonic code word generation")))((("mnemonic code words","generating"))) 助记词由钱包使用 BIP-39中定义的标准化过程自动生成。 钱包从一个熵源开始，添加一个校验和，然后将熵映射到一个单词列表:

1. 创建一个128到256位的加密随机序列 s。
2. 通过取其SHA256哈希的前部分（熵长度/32）来创建s的校验和。
3. 将校验和加到随机序列 s 的末尾。
4. 将第三步得到的s按照11bits划分。
5. 将每个11bits的值映射到预定义字典中的2048个词中的一个。
6. 根据顺序获取单词，就得到了助记词。

<<generating_entropy_and_encoding>> 显示了熵是如何用于生成助记词的。

<<table_bip39_entropy>> 表示熵数据的大小和记忆词长度之间的关系。

[[table_bip39_entropy]]
.助记词: 熵和单词的长度
[options="header"]
|=======
|熵(bits) | 校验和 (bits) | 熵 *+* 校验和 (bits) | 助记词长度 (words)
| 128 | 4 | 132 | 12
| 160 | 5 | 165 | 15
| 192 | 6 | 198 | 18
| 224 | 7 | 231 | 21
| 256 | 8 | 264 | 24
|=======

[[generating_entropy_and_encoding]]
[role="smallerseventy"]
.熵的生成及其编码为助记词
image::images/bip39-part1.png["Generating entropy and encoding as mnemonic words"]

[[mnemonic_to_seed]]
===== 从助记词到种子

((("BIP-39 standard","deriving seed from mnemonic words")))((("seeds","deriving from mnemonic code words")))助记词代表了128位到256位的熵。然后利用熵通过密钥扩展函数PBKDF2 ((("PBKDF2 function")))得到更长的（512位）种子。然后使用生成的种子构建确定性钱包并派生其密钥。

((("key-stretching function")))((("salts")))秘钥扩展函数有两个参数: 助记词和盐。 在秘钥扩展函数中加盐的目的是为了使通过创建一个查找表来暴力破解变得困难。 在 BIP-39标准中，加盐还有另一个用途: 它允许引入一个密码，作为保护种子的额外安全因素，我们将在 <<mnemonic_passphrase>> 中详细地描述这一点。

步骤7至步骤9所描述的过程继续自上一节所描述的过程:

[start=7]
7. Pbkdf2秘钥扩展函数的第一个参数是步骤6中产生的助记词。
8. Pbkdf2秘钥扩展函数的第二个参数是盐。 盐由常量"助记词"和一个可选的用户提供的密码组成。
9. Pbkdf2使用 HMAC-SHA512算法对助记词和盐进行了2048轮哈希计算，最终得到512位的值。 这个512位的值就是种子。

<<mnemonic_to_seed_figure>> 显示助记词是如何用来生成种子的。

[[mnemonic_to_seed_figure]]
.从助记词到种子
image::images/bip39-part2.png["From mnemonic to seed"]

[NOTE]
====
经过2048次哈希计算，秘钥扩展函数对于暴力破解助记词或密码提供了一些保护作用。尝试几千个助记词和密码的组合是非常昂贵的（在计算中）, 因为可能衍生的种子数量巨大 (2^512^, 或者大概 10^154^)&#x2014;远远超过可见宇宙中的原子数量 (大约 10^80^个).
====

表格 pass:[<a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_128_no_pass">#mnemonic_128_no_pass</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_128_w_pass">#mnemonic_128_w_pass</a>, 和 <a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_256_no_pass">#mnemonic_256_no_pass</a>] 展示了生产助记词和种子的一些例子。

[[mnemonic_128_no_pass]]
.128位熵生成的助记词, 不含密码, 得到种子
[cols="h,"]
|=======
| *输入熵(128 bits)*| +0c1e24e5917779d297e14d45f14e1a1a+
| *助记词 (12 words)* | +army van defense carry jealous true garbage claim echo media make crunch+
| *密码*| (none)
| *种子  (512 bits)* | +5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39+
+a88b76373733891bfaba16ed27a813ceed498804c0570+
|=======

[[mnemonic_128_w_pass]]
.128位熵生成的助记词, 含密码, 得到种子
[cols="h,"]
|=======
| *输入熵 (128 bits)*| +0c1e24e5917779d297e14d45f14e1a1a+
| *助记词 (12 words)* | +army van defense carry jealous true garbage claim echo media make crunch+
| *密码*| SuperDuperSecret
| *种子  (512 bits)* | +3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0+
+715861dc8a18358f80b79d49acf64142ae57037d1d54+
|=======

[role="pagebreak-before"]
[[mnemonic_256_no_pass]]
.256位熵生成的助记词, 不含密码, 得到种子
[cols="h,"]
|=======
| *输入熵 (256 bits)* | +2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c+
| *助记词 (24 words)* | +cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige+
| *密码*| (none)
| *种子 (512 bits)* | +3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5+
+5f1e0deaa082df8d487381379df848a6ad7e98798404+
|=======

[[mnemonic_passphrase]]
===== Optional passphrase in BIP-39

((("BIP-39 standard","optional passphrase with")))((("mnemonic code words","optional passphrase in BIP-39")))((("passphrases")))((("seeds","optional passphrase with")))The BIP-39 standard allows the use of an optional passphrase in the derivation of the seed. If no passphrase is used, the mnemonic is stretched with a salt consisting of the constant string +"mnemonic"+, producing a specific 512-bit seed from any given mnemonic. If a passphrase is used, the stretching function produces a _different_ seed from that same mnemonic. In fact, given a single mnemonic, every possible passphrase leads to a different seed. Essentially, there is no "wrong" passphrase. All passphrases are valid and they all lead to different seeds, forming a vast set of possible uninitialized wallets. The set of possible wallets is so large (2^512^) that there is no practical possibility of brute-forcing or accidentally guessing one that is in use, as long as the passphrase has sufficient complexity and length.

[TIP]
====
There are no "wrong" passphrases in BIP-39. Every passphrase leads to some wallet, which unless previously used will be empty.
====

The optional passphrase creates two important features:

* A second factor (something memorized) that makes a mnemonic useless on its own, protecting mnemonic backups from compromise by a thief.

* ((("duress wallet")))((("wallets","duress wallet")))A form of plausible deniability or "duress wallet," where a chosen passphrase leads to a wallet with a small amount of funds, used to distract an attacker from the "real" wallet that contains the majority of funds.

[role="pagebreak-before"]
However, it is important to note that the use of a passphrase also introduces the risk of loss:

* If the wallet owner is incapacitated or dead and no one else knows the passphrase, the seed is useless and all the funds stored in the wallet are lost forever.

* Conversely, if the owner backs up the passphrase in the same place as the seed, it defeats the purpose of a second factor.

While passphrases are very useful, they should only be used in combination with a carefully planned process for backup and recovery, considering the possibility of heirs surviving the owner being able to recover the cryptocurrency.

[[working_mnemonic_codes]]
===== Working with mnemonic codes

((("BIP-39 standard","libraries")))((("BIP-39 standard","working with mnemonic codes")))BIP-39 is implemented as a library in many different programming languages. For example:

https://github.com/trezor/python-mnemonic[python-mnemonic]:: The reference implementation of the standard by the SatoshiLabs team that proposed BIP-39, in Python

https://github.com/ConsenSys/eth-lightwallet[ConsenSys/eth-lightwallet]:: Lightweight JS Ethereum wallet for nodes and browser (with BIP-39)

https://www.npmjs.com/package/bip39[npm/bip39]:: JavaScript implementation of Bitcoin BIP-39: Mnemonic code for generating deterministic keys

There is also a BIP-39 generator implemented in a standalone web page (<<a_bip39_generator_as_a_standalone_web_page>>), which is extremely useful for testing and experimentation. The https://iancoleman.io/bip39/[Mnemonic Code Converter] generates mnemonics, seeds, and extended private keys. It can be used offline in a browser, or accessed online.(((range="endofrange", startref="ix_05wallets-asciidoc9")))(((range="endofrange", startref="ix_05wallets-asciidoc8")))(((range="endofrange", startref="ix_05wallets-asciidoc7")))(((range="endofrange", startref="ix_05wallets-asciidoc6")))

[[a_bip39_generator_as_a_standalone_web_page]]
.A BIP-39 generator as a standalone web page
image::images/bip39_web.png["BIP-39 generator web-page"]

[[create_hd_wallet]]
==== Creating an HD Wallet from the Seed

((("hierarchical deterministic wallets (BIP-32/BIP-44)","creating from root seed")))((("root seeds, creating HD wallets from")))((("wallets","creating HD wallets from root seed")))HD wallets are created from a single _root seed_, which is a 128-, 256-, or 512-bit random number. Most commonly, this seed is generated from a mnemonic as detailed in the previous section.

Every key in the HD wallet is deterministically derived from this root seed, which makes it possible to recreate the entire HD wallet from that seed in any compatible HD wallet. This makes it easy to export, back up, restore, and import HD wallets containing thousands or even millions of keys by transferring just the mnemonic from which the root seed is derived.

[[bip32_bip43_44]]
==== HD Wallets (BIP-32) and Paths (BIP-43/44)

((("Bitcoin improvement proposals (BIPs)","Multipurpose HD Wallet Structure (BIP-43)", id="ix_05wallets-asciidoc10", range="startofrange")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","HD wallets (BIP-32) and paths (BIP-43/44)", id="ix_05wallets-asciidoc11", range="startofrange")))Most HD wallets follow the ((("BIP-32 standard","HD wallets and", id="ix_05wallets-asciidoc12", range="startofrange")))BIP-32 standard, which has become a _de facto_ industry standard for deterministic key generation.

We won't be discussing all the details of BIP-32 here, only the components necessary to understand how it is used in wallets. The main important aspect is the tree-like hierarchical relationships that it is possible for the derived keys to have, as you can see in <<hd_wallets_figure>>. It's also important to understand the ideas of _extended keys_ and _hardened keys_, which are explained in the following sections.

There are dozens of interoperable implementations of BIP-32 offered in many software libraries. These are mostly designed for Bitcoin wallets, which implement addresses in a different way, but share the same key-derivation implementation as Ethereum's BIP-32-compatible wallets. Use one https://github.com/ConsenSys/eth-lightwallet[designed for Ethereum], or adapt one from Bitcoin by adding an Ethereum address encoding library.

There is also a BIP-32 generator implemented as a http://bip32.org/[standalone web page] that is very useful for testing and experimentation with BIP-32.

[WARNING]
====
The standalone BIP-32 generator is not an HTTPS site. That's to remind you that the use of this tool is not secure. It is only for testing. You should not use the keys produced by this site with real funds.
====

[[extended_keys]]
===== Extended public and private keys

((("BIP-32 standard","extended public and private keys")))((("extended keys")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","extended public and private keys")))((("keys","extended")))In BIP-32 terminology, keys can be "extended.&#x201d; With the right mathematical operations, these extended "parent" keys can be used to derive "child" keys, thus producing the hierarchy of keys and addresses described earlier. A parent key doesn't have to be at the top of the tree. It can be picked out from anywhere in the tree hierarchy. ((("chain code")))Extending a key involves taking the key itself and appending a special _chain code_ to it. A chain code is a 256-bit binary string that is mixed with each key to produce child keys.

((("private keys","extended")))If the key is a private key, it becomes an _extended private key_ distinguished by the pass:[<span class="keep-together">prefix</span>] +xprv+:

[[xprv_example]]
----
xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i...
----

((("public keys","extended")))An _extended public key_ is distinguished by the prefix +xpub+:

[[xpub_example]]
----
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn...
----

A very useful characteristic of HD wallets is the ability to derive child public keys from parent public keys, _without_ having the private keys. This gives us two ways to derive a child public key: either directly from the child private key, or from the parent public key.

An extended public key can be used, therefore, to derive all of the public keys (and only the public keys) in that branch of the HD wallet structure.

This shortcut can be used to create very secure public key&#x2013;only deployments, where a server or application has a copy of an extended public key, but no private keys whatsoever. That kind of deployment can produce an infinite number of public keys and Ethereum addresses, but cannot spend any of the money sent to those addresses. Meanwhile, on another, more secure server, the extended private key can derive all the corresponding private keys to sign transactions and spend the money.

One common application of this method is to install an extended public key on a web server that serves an ecommerce application. The web server can use the public key derivation function to create a new Ethereum address for every transaction (e.g., for a customer shopping cart), and will not have any private keys that would be vulnerable to theft. Without HD wallets, the only way to do this is to generate thousands of Ethereum addresses on a separate secure server and then preload them on the ecommerce server. That approach is cumbersome and requires constant maintenance to ensure that the server doesn't run out of keys, hence the preference to use extended public keys from HD wallets.

((("hardware wallets")))Another common application of this solution is for ((("cold-storage wallets")))((("wallets","cold-storage wallets")))cold-storage or hardware wallets. In that scenario, the extended private key can be stored in a hardware wallet, while the extended public key can be kept online. The user can create "receive" addresses at will, while the private keys are safely stored offline. To spend the funds, the user can use the extended private key in an offline signing Ethereum client, or sign transactions on the hardware wallet device.

[[hardened_child_key]]
===== Hardened child key derivation

((("child private keys")))((("hardened derivation","for child private keys")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","hardened child key derivation")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","index numbers for normal/hardened derivation")))((("index numbers, for normal/hardened derivation")))((("private keys","hardened child key derivation")))The ability to derive a branch of public keys from an extended public key, or _xpub_, is very useful, but it comes with a potential risk. Access to an xpub does not give access to child private keys. However, because the xpub contains the chain code (used to derive child public keys from the parent public key), if a child private key is known, or somehow leaked, it can be used with the chain code to derive all the other child private keys. A single leaked child private key, together with a parent chain code, reveals all the private keys of all the children. Worse, the child private key together with a parent chain code can be used to deduce the parent private key.

To counter this risk, HD wallets use an alternative derivation function called _hardened derivation_, which "breaks" the relationship between parent public key and child chain code. The hardened derivation function uses the parent private key to derive the child chain code, instead of the parent public key. This creates a "firewall" in the parent/child sequence, with a chain code that cannot be used to compromise a parent or sibling private key.

In simple terms, if you want to use the convenience of an xpub to derive branches of public keys without exposing yourself to the risk of a leaked chain code, you should derive it from a hardened parent, rather than a normal parent. Best practice is to have the level-1 children of the master keys always derived by hardened derivation, to prevent compromise of the master keys.

[[index_number]]
===== Index numbers for normal and hardened derivation

((("hardened derivation","index numbers for")))It is clearly desirable to be able to derive more than one child key from a given parent key. To manage this, an index number is used. Each index number, when combined with a parent key using the special child derivation function, gives a different child key. The index number used in the BIP-32 parent-to-child derivation function is a 32-bit integer. To easily distinguish between keys derived through the normal (unhardened) derivation function versus keys derived through hardened derivation, this index number is split into two ranges. Index numbers between 0 and 2^31^&#x2013;1 (+0x0+ to +0x7FFFFFFF+) are used _only_ for normal derivation. Index numbers between 2^31^ and 2^32^&#x2013;1 (+0x80000000+ to +0xFFFFFFFF+) are used _only_ for hardened derivation. Therefore, if the index number is less than 2^31^, the child is normal, whereas if the index number is equal to or above 2^31^, the child is hardened.

To make the index numbers easier to read and display, the index numbers for hardened children are displayed starting from zero, but with a prime symbol. The first normal child key is therefore displayed as +0+, whereas the first hardened child (index +0x80000000+) is displayed as ++0&#x27;++. In sequence, then, the second hardened key would have index of +0x80000001+ and would be displayed as ++1&#x27;++, and so on. When you see an HD wallet index ++i&#x27;++, that means 2^31^ pass:[+] ++i++.(((range="endofrange", startref="ix_05wallets-asciidoc12")))

[[hd_wallet_path]]
===== HD wallet key identifier (path)

((("hierarchical deterministic wallets (BIP-32/BIP-44)","key identifier")))((("keys","path naming convention")))Keys in an HD wallet are identified using a "path" naming convention, with each level of the tree separated by a slash (/) character (see <<hd_path_table>>). Private keys derived from the master private key start with +m+. Public keys derived from the master public key start with +M+. Therefore, the first child private key of the master private key is +m/0+. The first child public key is +M/0+. The second grandchild of the first child is +m/0/1+, and so on.

The "ancestry" of a key is read from right to left, until you reach the master key from which it was derived. For example, identifier +m/x/y/z+ describes the key that is the ++z++-th child of key +m/x/y+, which is the ++y++-th child of key +m/x+, which is the ++x++-th child of +m+.

[[hd_path_table]]
.HD wallet path examples
[options="header"]
|=======
|HD path | Key described
| +m/0+ | The first (+0+) child private key of the master private key (+m+)
| +m/0/0+ | The first grandchild private key of the first child (+m/0+)
| +m/0'/0+ | The first normal grandchild of the first _hardened_ child (+m/0'+)
| +m/1/0+ | The first grandchild private key of the second child (+m/1+)
| +M/23/17/0/0+ | The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the pass:[<span class="keep-together">24th child</span>]
|=======

[[navigating_hd_wallet_tree]]
===== Navigating the HD wallet tree structure

((("hierarchical deterministic wallets (BIP-32/BIP-44)","tree structure")))((("tree structure, navigating")))The HD wallet tree structure is tremendously flexible. The flip side of this is that it also allows for unbounded complexity: each parent extended key can have 4 billion children: 2 billion normal children and 2 billion hardened children. Each of those children can have another 4 billion children, and so on. The tree can be as deep as you want, with a potentially infinite number of generations. With all that potential, it can become quite difficult to navigate these very large trees.

Two BIPs offer a way to manage this potential complexity by creating standards for the structure of HD wallet trees. ((("BIP-43 standard")))BIP-43 proposes the use of the first hardened child index as a special identifier that signifies the "purpose" of the tree structure. Based on BIP-43, an HD wallet should use only one level-1 branch of the tree, with the index number defining the purpose of the wallet by identifying the structure and namespace of the rest of the tree. More specifically, an HD wallet using only branch ++m/i&#x27;/...++ is intended to signify a specific purpose and that purpose is identified by index number +i+.

((("BIP-44 standard")))Extending that specification, BIP-44 proposes a multicurrency multiaccount structure signified by setting the "purpose" number to +44'+. All HD wallets following the BIP-44 structure are identified by the fact that they only use one branch of the tree: +m/44'/*+.

BIP-44 specifies the structure as consisting of five predefined tree levels:

[[bip44_tree]]
-----
m / purpose' / coin_type' / account' / change / address_index
-----

The first level, +purpose&#x27;+, is always set to +44&#x27;+. The second level, +coin_type&#x27;+, specifies the type of cryptocurrency coin, allowing for multicurrency HD wallets where each currency has its own subtree under the second level. There are several currencies defined in a standards document called https://github.com/satoshilabs/slips/blob/master/slip-0044.md[SLIP0044]; for example, Ethereum is ++m/44&#x27;/60&#x27;++, Ethereum Classic is ++m/44&#x27;/61&#x27;++, Bitcoin is ++m/44&#x27;/0&#x27;++, and Testnet for all currencies is ++m/44&#x27;/1&#x27;++.

The third level of the tree is +account&#x27;+, which allows users to subdivide their wallets into separate logical subaccounts for accounting or organizational purposes. For example, an HD wallet might contain two Ethereum "accounts": ++m/44&#x27;/60&#x27;/0&#x27;++ and ++m/44&#x27;/60&#x27;/1&#x27;++. Each account is the root of its own subtree.

Because BIP-44 was created originally for Bitcoin, it contains a "quirk" that isn't relevant in the Ethereum world. On the fourth level of the path, +change+, an HD wallet has two subtrees: one for creating receiving addresses and one for creating change addresses. Only the "receive" path is used in Ethereum, as there is no necessity for a change address like there is in Bitcoin. Note that whereas the previous levels used hardened derivation, this level uses normal derivation. This is to allow the account level of the tree to export extended public keys for use in a nonsecured environment. Usable addresses are derived by the HD wallet as children of the fourth level, making the fifth level of the tree the +address_index+. For example, the third receiving address for Ethereum payments in the primary account would be ++M/44&#x27;/60&#x27;/0&#x27;/0/2++. <<bip44_path_examples>> shows a few more examples(((range="endofrange", startref="ix_05wallets-asciidoc11")))(((range="endofrange", startref="ix_05wallets-asciidoc10"))).(((range="endofrange", startref="ix_05wallets-asciidoc5")))

[[bip44_path_examples]]
.BIP-44 HD wallet structure examples
[options="header"]
|=======
|HD path | Key described
| ++M/44&#x27;/60&#x27;/0&#x27;/0/2++ | The third receiving public key for the primary Ethereum account
| ++M/44&#x27;/0&#x27;/3&#x27;/1/14++ | The 15^th^ change-address public key for the 4^th^ Bitcoin account
| ++m/44&#x27;/2&#x27;/0&#x27;/0/1++ | The second private key in the Litecoin main account, for signing transactions
|=======

=== Conclusions

Wallets are the foundation of any user-facing blockchain application. They allow users to manage collections of keys and addresses. Wallets also allow users to demonstrate their ownership of ether, and authorize transactions, by applying digital signatures, as we will see in <<tx_chapter>>.(((range="endofrange", startref="ix_05wallets-asciidoc0")))
